<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <link rel="preload" href="../fonts/ComicMono.ttf" as="font" type="font/ttf" crossorigin>
    <link rel="preload" href="../fonts/9Bt23C1KxNDXMspQ1lPyU89-1h6ONRlW45G04pIo.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="../fonts/dina.woff2" as="font" type="font/woff2" crossorigin>

    <link rel="stylesheet" href="../styles/darkstyle.css">
    
    <title>Prompt Assembly</title>

    <style>
        /* DEFINE FONT */
        @font-face {
            font-family: 'Comic Mono';
            src: url('../fonts/ComicMono.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        /* BUTTON STYLING */
        .terminal-btn {
            font-family: 'Comic Mono', monospace;
            font-size: 1.2rem;
            background: transparent;
            color: #FF4444; /* Red */
            border: none;
            padding: 10px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            
            /* CRITICAL: Disables the default blue browser highlight on mobile */
            -webkit-tap-highlight-color: transparent; 
            
            transition: background 0.05s ease; /* Super fast transition for snappiness */
            outline: none;
        }
        
        .copy-state {
            color: #09CC50; /* Green for Copy */
        }

        /* COMPUTER ONLY: Hover Effect */
        @media (hover: hover) {
            .terminal-btn:hover {
                background: #FF4444;
                color: #000;
            }
            .terminal-btn:disabled:hover {
                background: transparent;
                color: #555;
                cursor: default; /* Changed from not-allowed to default arrow */
            }
            .copy-state:hover {
                background: #09CC50;
                color: #000;
            }
        }
        
        /* OPTIONAL: Visual feedback when actually clicking/tapping */
        .terminal-btn:active {
            background: #FF4444;
            color: #000;
        }
        .copy-state:active {
            background: #09CC50;
            color: #000;
        }

        /* CLASS for interactive text in terminal */
        .clickable-text {
            cursor: pointer;
            color: #00AAA0;
        }
        .clickable-text:hover {
            text-decoration: underline;
        }

        /* NEW: Clickable Labels (No color change, just pointer/underline) */
        .clickable-label {
            cursor: pointer;
        }
        .clickable-label:hover {
            text-decoration: underline;
        }

        /* INPUT FIELD STYLING */
        .terminal-input {
            background: transparent;
            border: 1px solid #09CC50;
            color: #09CC50;
            font-family: 'Comic Mono', monospace;
            font-size: 0.9rem;
            padding: 5px;
            width: 60%;
            margin-bottom: 5px;
            outline: none;
            display: inline-block;
        }
        .terminal-input:focus {
            background: #001100;
            border-color: #00AAA0;
        }
        /* Placeholder styling */
        .terminal-input::placeholder {
            color: #09CC50;
            opacity: 0.4;
        }
        
        /* Disabled button state */
        .terminal-btn:disabled {
            opacity: 1; 
            cursor: default; 
            background: transparent !important;
            color: #555 !important; /* Grey color */
        }
    </style>
</head>
<body>
    
    <div class="machine-container" style="max-width: 850px; margin: 0 auto;">

        <div style="background: #000; color: #09CC50; font-family: 'Comic Mono', monospace; padding: 25px; border: 1px solid #333; line-height: 1.5;">
            
<div style="display: flex; flex-wrap: wrap; align-items: flex-start; gap: 30px; margin-bottom: 20px;">

  <!-- LEFT: ASCII LOGO -->
  <div style="flex-shrink: 0;">
<pre style="color: #FF4444; font-family: 'Comic Mono', monospace; line-height: 1.1; text-align: left; margin: 0;">
         <span style="color: #00AAA0;">\</span> ,,:::,,
       .: <span style="color: #00AAA0;">\</span>       '::.
     .::'  <span style="color: #00AAA0;">\</span>        '::.
    :::    <span style="color: #00AAA0;">/</span>          :::
    :::   <span style="color: #00AAA0;">/</span>           :::
     ':: <span style="color: #00AAA0;">/</span>          .::'
        <span style="color: #00AAA0;">/</span> ..     ..::'
       <span style="color: #00AAA0;">V</span>   '':::''
</pre>
  </div>

  <!-- RIGHT: TITLE + PROMPT TEXT -->
  <div style="flex: 1 1 280px; min-width: 280px;">

    <h1 style="margin: 0; line-height: 1; font-size: 1.8rem;">
      <a href="../index.html" title="back" style="color: inherit; text-decoration: none;">Philosophy Jailbreak</a>
    </h1>

    <h2 style="margin: 5px 0 0 0; font-size: 1.1rem; opacity: 0.9;"><em>// Prompt Assembly</em></h2>

    <div class="reference" style="margin-bottom: 15px; font-size: 0.8rem; opacity: 0.7;">
      v1.2.5
    </div>

    <div style="font-size: 0.9rem; line-height: 1.4;">
      <b>DIRECTIVE:</b> Force any philosophical system into a posture of estrangement and equivalence with other practices.<br>
      <b>QUICKSTART:</b> Assemble a prompt (auto-copied to clipboard). Paste into an AI chatbot with internet access.<br>
      <b>HINT:</b> Try
      <a href="https://www.perplexity.ai/" target="_blank" title="Perplexity"
         style="color: #00AAA0; text-decoration: none;"
         onmouseover="this.style.textDecoration='underline'"
         onmouseout="this.style.textDecoration='none'">Perplexity</a>.
    </div>

  </div>

</div>


            <div id="hex-stream" style="margin-bottom: 20px; font-size: 0.9rem; white-space: nowrap; overflow: hidden;">
                > 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
            </div>

            <div id="terminal-display" 
                 style="text-align: left; 
                        min-height: 80px;
                        font-size: 0.9rem;
                        margin-bottom: 20px;
                        word-break: break-all;">
                <!-- Content injected by JS -->
            </div>

            <!-- ADDED: align-items: center to fix button width -->
            <div align="center" style="display: flex; flex-direction: column; gap: 10px; align-items: center;">
                <!-- SINGLE BUTTON FOR ALL ACTIONS -->
                <button id="actionBtn" 
                        class="terminal-btn"
                        onclick="handleAction()">
                    >>>> ASSEMBLE <<<<
                </button>
            </div>
            
        </div>

    </div> <script src="data.js"></script>

<script>
    // --- 0. STATE MANAGEMENT ---
    let isManualMode = false;
    let lastGeneratedData = {
        target: "",
        link: "",
        vector: "",
        promptText: "",
        isCopied: false,
        // Track the exact pair that was auto-generated to detect conflicts
        autoTarget: "",
        autoSource: ""
    };

    // Initial Render
    document.addEventListener("DOMContentLoaded", () => {
        renderTerminalState("ready");
    });

    function toggleMode() {
        // If currently in Manual Mode, capture inputs before switching
        if (isManualMode) {
            const t = document.getElementById("manual-target")?.value;
            const s = document.getElementById("manual-source")?.value;
            const v = document.getElementById("manual-vector")?.value;
            // Only update if they exist (to avoid undefined/null overwrites)
            if (t !== undefined) lastGeneratedData.target = t;
            if (s !== undefined) lastGeneratedData.link = s;
            if (v !== undefined) lastGeneratedData.vector = v;
        }

        isManualMode = !isManualMode;
        renderTerminalState("ready");
    }

    // --- 1. RENDER LOGIC ---
    function renderTerminalState(state, data = {}) {
        const terminal = document.getElementById("terminal-display");
        const actionBtn = document.getElementById("actionBtn");
        
        const modeLabel = isManualMode ? "MANUAL" : "AUTOMATIC";
        const nextModeLabel = isManualMode ? "AUTOMATIC" : "MANUAL";
        
        // Header: SYSTEM is now clickable via clickable-label class
        const header = `> <b class="clickable-label" onclick="toggleMode()">SYSTEM:</b> <span id="mode-text" class="clickable-text" onclick="toggleMode()" title="Click to switch to ${nextModeLabel}">${modeLabel}</span><br>`;
        
        // Determine values based on State
        let displayTarget = "";
        let displaySource = "";
        let displayVector = "";
        let displayStatus = "READY"; // Default status

        // 1. Resolve Values based on State & Data
        if (state === "processing") {
            displayStatus = "GENERATING...";
            if (isManualMode) {
                // Manual Processing: Show existing vals or [FETCHING...]
                displayTarget = data.processingFields?.target ? "[FETCHING...]" : (data.currentValues?.target || "");
                displaySource = data.processingFields?.source ? "[FETCHING...]" : (data.currentValues?.source || "");
                displayVector = data.processingFields?.vector ? "[FETCHING...]" : (data.currentValues?.vector || "");
            } else {
                // Auto Processing: Everything is fetching
                displayTarget = "[FETCHING...]";
                displaySource = "[FETCHING...]";
                displayVector = "[FETCHING...]";
            }
        } else if (state === "result") {
            // Result State: Use provided data
            displayTarget = data.target || "";
            displaySource = data.link || "";
            displayVector = data.vector || "";
            displayStatus = data.label || "PAYLOAD GENERATED";
        } else {
            // Ready State: Use stored data (Persistence)
            displayTarget = lastGeneratedData.target || "";
            displaySource = lastGeneratedData.link || "";
            displayVector = lastGeneratedData.vector || "";
            
            // Logic for status based on persistence
            // NOTE: This status might get overwritten by conflict checks in Manual Input Handler
            if (lastGeneratedData.isCopied) {
                displayStatus = "COPIED TO CLIPBOARD";
            } else {
                displayStatus = lastGeneratedData.promptText ? "NOT COPIED" : "READY";
            }
        }

        // Determine Status Color logic for Initial Render
        let statusStyle = "";
        if (displayStatus.includes("CONFLICT")) {
            statusStyle = "style='color: #FF4444;'";
        }

        // 2. Construct HTML based on Mode
        let bodyHTML = "";

        if (isManualMode) {
            // MANUAL MODE: Render INPUTS
            // Hidden Feature: TARGET, SOURCE, VECTOR are clickable labels to spin individually
            // Pass argument 'target' or 'source' to distinguish click intent
            const targetPlaceholder = (displaySource !== "" && displaySource !== "[FETCHING...]") ? "[AUTO-DETECT]" : "[RANDOM]";
            const disabledAttr = (state === "processing") ? "disabled" : "";
            
            bodyHTML = `
                > <b class="clickable-label" onclick="manualSpinPair('target')">TARGET:</b> <input type="text" id="manual-target" class="terminal-input" placeholder="${targetPlaceholder}" value="${displayTarget}" oninput="handleManualInput()" ${disabledAttr}><br>
                > <b class="clickable-label" onclick="manualSpinPair('source')">SOURCE:</b> <input type="text" id="manual-source" class="terminal-input" placeholder="[RANDOM]" value="${displaySource}" oninput="handleManualInput()" ${disabledAttr}><br>
                > <b class="clickable-label" onclick="manualSpinVector()">VECTOR:</b> <input type="text" id="manual-vector" class="terminal-input" placeholder="[RANDOM]" value="${displayVector}" oninput="handleManualInput()" ${disabledAttr}><br>
                > ---------------------------<br>
                > <b>STATUS:</b> <span id="status-line" ${statusStyle}>${displayStatus}</span>
            `;
        } else {
            // AUTOMATIC MODE: Render TEXT (Visual Consistency)
            // Note: TARGET, SOURCE, VECTOR are NOT clickable labels here
            let sourceDisplayHtml = displaySource;
            if (displaySource.startsWith("http") && state !== "processing") {
                sourceDisplayHtml = `<a href="${displaySource}" target="_blank" style="color: #00AAA0; text-decoration: none;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${displaySource}</a>`;
            }

            bodyHTML = `
                > <b>TARGET:</b> ${displayTarget}<br>
                > <b>SOURCE:</b> ${sourceDisplayHtml}<br>
                > <b>VECTOR:</b> ${displayVector}<br>
                > ---------------------------<br>
                > <b>STATUS:</b> <span id="status-line" ${statusStyle}>${displayStatus}</span>
            `;
        }

        // 3. Inject
        terminal.innerHTML = header + bodyHTML;

        // 4. Update Button (Processing state overrides button text logic)
        if (state === "processing") {
            actionBtn.disabled = true;
            actionBtn.innerText = ">>>> PROCESSING <<<<";
            actionBtn.className = "terminal-btn";
        } else {
            // Force update button logic (which might verify conflicts and update status text again)
            updateButtonState();
        }
        
        terminal.style.color = ""; 
    }

    // --- 2. INPUT HANDLERS & BUTTON STATE ---

    // Utility: Run Hex Stream Animation for a set duration
    function runHexAnimation(duration) {
        const hexStream = document.getElementById("hex-stream");
        if (!hexStream) return;
        
        const interval = setInterval(() => {
            hexStream.innerText = getRandomHexLine();
        }, 50);
        
        setTimeout(() => {
            clearInterval(interval);
            hexStream.innerText = getRandomHexLine();
        }, duration);
    }

    // NEW: Hidden Feature Handlers
    function manualSpinPair(clickedField) {
        if(!isManualMode) return;
        
        const tInput = document.getElementById("manual-target");
        const sInput = document.getElementById("manual-source");
        const currentSource = sInput.value.trim();

        // Start Animation (Reduced to 300ms)
        const SPIN_DURATION = 300;
        runHexAnimation(SPIN_DURATION);

        // Detect if current source is user-entered (manual) or system-generated (auto)
        // If it's empty, we treat it as auto (needs a spin)
        const isManualSource = (currentSource !== "" && currentSource !== lastGeneratedData.autoSource);

        // LOGIC:
        // If user clicks TARGET and they have a MANUAL source -> Guess the target name from the URL.
        // If user clicks SOURCE -> They want a new pair (Source+Target).
        // If user clicks TARGET but source is AUTO -> We shouldn't overwrite valid data with a guess -> Spin new pair.
        
        if (clickedField === 'target' && isManualSource) {
            // GUESS MODE
            tInput.value = "[FETCHING...]";
            
            setTimeout(() => {
                const guessedTitle = tryExtractTitleFromUrl(currentSource);
                const finalTitle = guessedTitle ? guessedTitle : "[INDETERMINATE]";
                
                tInput.value = finalTitle;
                
                // Update State
                lastGeneratedData.target = finalTitle;
                lastGeneratedData.link = currentSource;
                
                // Treat this pair as the new valid baseline to prevent conflicts
                lastGeneratedData.autoTarget = finalTitle;
                lastGeneratedData.autoSource = currentSource;
                
                handleManualInput();
            }, SPIN_DURATION);

        } else {
            // SPIN MODE (New Pair)
            if (tInput) tInput.value = "[FETCHING...]";
            if (sInput) sInput.value = "[FETCHING...]";
            
            setTimeout(() => {
                const articleObj = articles[Math.floor(Math.random() * articles.length)];
                
                // Update DOM
                if (tInput) tInput.value = articleObj.title;
                if (sInput) sInput.value = articleObj.link;
                
                // Update State
                lastGeneratedData.target = articleObj.title;
                lastGeneratedData.link = articleObj.link;
                
                // Update Conflict Baseline
                lastGeneratedData.autoTarget = articleObj.title;
                lastGeneratedData.autoSource = articleObj.link;

                // Trigger standard handler to update button/status
                handleManualInput();
            }, SPIN_DURATION);
        }
    }

    function manualSpinVector() {
        if(!isManualMode) return;
        
        // Start Animation (Reduced to 300ms)
        const SPIN_DURATION = 300;
        runHexAnimation(SPIN_DURATION);

        const vInput = document.getElementById("manual-vector");
        if (vInput) vInput.value = "[FETCHING...]";
        
        setTimeout(() => {
            const vector = lenses[Math.floor(Math.random() * lenses.length)];
            
            if (vInput) vInput.value = vector;
            lastGeneratedData.vector = vector;
            
            handleManualInput();
        }, SPIN_DURATION);
    }
    
    function handleManualInput() {
        // Mark state as dirty (not matched with clipboard)
        lastGeneratedData.isCopied = false;
        
        // Reset Status to "NOT COPIED" initially (and clear color)
        const statusEl = document.getElementById("status-line");
        if (statusEl) {
            statusEl.innerText = "NOT COPIED";
            statusEl.style.color = ""; // Reset to default color
        }

        updateTargetPlaceholder();
        updateButtonState();
    }

    function updateTargetPlaceholder() {
        const sourceEl = document.getElementById("manual-source");
        const targetEl = document.getElementById("manual-target");
        if (!sourceEl || !targetEl) return;
        targetEl.placeholder = (sourceEl.value.trim() !== "") ? "[AUTO-DETECT]" : "[RANDOM]";
    }

    function updateButtonState() {
        const btn = document.getElementById("actionBtn");
        const statusEl = document.getElementById("status-line");
        if (!btn) return;
        
        // Default Button State (Active)
        btn.disabled = false;
        btn.innerText = ">>>> ASSEMBLE <<<<";
        btn.className = "terminal-btn";

        if (!isManualMode) {
            btn.onclick = assembleAndCopy;
            return;
        }

        // --- MANUAL MODE LOGIC ---
        const t = document.getElementById("manual-target")?.value.trim() || "";
        const s = document.getElementById("manual-source")?.value.trim() || "";
        const v = document.getElementById("manual-vector")?.value.trim() || "";
        
        // Check for Conflicts
        const autoT = lastGeneratedData.autoTarget || "";
        const autoS = lastGeneratedData.autoSource || "";

        let hasConflict = false;
        let conflictMsg = "";

        if (s !== "" && s !== autoS && t !== "" && t === autoT) {
            hasConflict = true;
            conflictMsg = "TARGET CONFLICT";
        }
        else if (t !== "" && t !== autoT && s !== "" && s === autoS) {
            hasConflict = true;
            conflictMsg = "SOURCE CONFLICT";
        }

        if (hasConflict) {
            btn.disabled = true;
            btn.innerText = ">>>> ERROR <<<<"; // NEW: Explicit Error Text
            if (statusEl) {
                statusEl.innerText = conflictMsg;
                statusEl.style.color = "#FF4444"; 
            }
            return; 
        }

        // If no conflict, check copy state
        const isCopied = lastGeneratedData.isCopied; 

        if (t && s && v) {
            // All fields filled
            if (isCopied) {
                // If already copied and no changes made, disable button
                btn.disabled = true;
                btn.innerText = ">>>> COPIED <<<<"; // NEW: Explicit Copied Text
                
                if (statusEl && statusEl.innerText !== "COPIED TO CLIPBOARD") {
                     statusEl.innerText = "COPIED TO CLIPBOARD";
                     statusEl.style.color = ""; 
                }
            } else {
                // Fields filled but changed/not copied -> Enable Copy
                btn.onclick = copyOnly;
            }
        } else {
            // Blanks exist -> Assemble Function
            btn.onclick = assembleAndCopy; 
        }
    }

    function handleAction() {
        assembleAndCopy();
    }

    // --- 3. CORE LOGIC ---

    function assembleAndCopy() {
        // 1. Gather Inputs
        let inputTarget = null, inputSource = null, inputVector = null;
        let currentVals = {};

        // In Manual mode, read DOM. In Auto mode, we start blank (or re-roll).
        if (isManualMode) {
            const elTarget = document.getElementById("manual-target");
            const elSource = document.getElementById("manual-source");
            const elVector = document.getElementById("manual-vector");
            
            if (elTarget) currentVals.target = elTarget.value;
            if (elSource) currentVals.source = elSource.value;
            if (elVector) currentVals.vector = elVector.value;

            if (elTarget && elTarget.value.trim() !== "") inputTarget = elTarget.value.trim();
            if (elSource && elSource.value.trim() !== "") inputSource = elSource.value.trim();
            if (elVector && elVector.value.trim() !== "") inputVector = elVector.value.trim();
        }

        // Determine Processing Fields
        // Manual: Only blanks are processing. Auto: All are processing.
        let processingFields = {};
        if (isManualMode) {
             processingFields = {
                target: !inputTarget || !inputSource, 
                source: !inputSource,
                vector: !inputVector
            };
        } else {
            // Auto Mode: Everything refreshes
            processingFields = { target: true, source: true, vector: true };
        }

        const terminal = document.getElementById("terminal-display");
        const hexStream = document.getElementById("hex-stream");

        // RENDER PROCESSING STATE
        renderTerminalState("processing", {
            currentValues: currentVals,
            processingFields: processingFields
        });

        // Spin
        const scrambleInterval = setInterval(() => {
            hexStream.innerText = getRandomHexLine();
        }, 50);

        // Faster Spin Time (Reduced from 700 to 450)
        const MIN_SPIN_TIME = 450; 
        const startTime = Date.now();

        // 2. Compute Values (Logic)
        let target, link;
        
        // Track what logic generated this pair to save for conflict detection
        let newAutoTarget = "";
        let newAutoSource = "";

        if (inputTarget && inputSource) {
            target = inputTarget; link = inputSource;
            // User provided both: these count as "Auto" for conflict checking going forward
            newAutoTarget = target;
            newAutoSource = link;
        } else if (!inputSource) {
            // If Source missing, fetch pair.
            const articleObj = articles[Math.floor(Math.random() * articles.length)];
            target = articleObj.title; link = articleObj.link;
            // These are the new "Auto" baseline
            newAutoTarget = target;
            newAutoSource = link;
        } else if (!inputTarget && inputSource) {
            link = inputSource;
            const extractedTitle = tryExtractTitleFromUrl(link);
            target = extractedTitle ? extractedTitle : "[INDETERMINATE]";
            // These are the new "Auto" baseline
            newAutoTarget = target;
            newAutoSource = link;
        }
        let vector = inputVector ? inputVector : lenses[Math.floor(Math.random() * lenses.length)];

        // 3. Generate Prompt
        const promptText = createPromptText(target, link, vector);

        // Update State (isCopied defaults false until copy confirms)
        lastGeneratedData = { 
            target, 
            link, 
            vector, 
            promptText, 
            isCopied: false,
            autoTarget: newAutoTarget,
            autoSource: newAutoSource
        };

        // 4. Copy & Finalize
        performCopy(promptText, () => {
             const elapsed = Date.now() - startTime;
             const remaining = Math.max(0, MIN_SPIN_TIME - elapsed);
             
             setTimeout(() => {
                clearInterval(scrambleInterval);
                hexStream.innerText = getRandomHexLine();
                terminal.style.color = "#09CC50";
                
                lastGeneratedData.isCopied = true; // Mark success

                renderTerminalState("result", {
                    target: target,
                    link: link,
                    vector: vector,
                    label: "COPIED TO CLIPBOARD"
                });
             }, remaining);
        });
    }

    function copyOnly() {
        if (!isManualMode) return; 
        const t = document.getElementById("manual-target").value;
        const s = document.getElementById("manual-source").value;
        const v = document.getElementById("manual-vector").value;
        const promptText = createPromptText(t, s, v);
        
        // When manually copying, we update the "Auto" baseline to match current inputs
        // This prevents immediate "conflict" if the user starts editing from this point.
        lastGeneratedData = { 
            target: t, 
            link: s, 
            vector: v, 
            promptText, 
            isCopied: false,
            autoTarget: t,
            autoSource: s
        };

        performCopy(promptText, () => {
            lastGeneratedData.isCopied = true; // Mark success
            renderTerminalState("result", {
                target: t, link: s, vector: v, 
                label: "COPIED TO CLIPBOARD"
            });
        });
    }

    function performCopy(text, callback) {
        if (!navigator.clipboard) {
            copyToClipboardFallback(text);
            if (callback) callback();
            return;
        }
        navigator.clipboard.writeText(text).then(() => {
            if (callback) callback();
        }).catch(err => {
            copyToClipboardFallback(text);
            if (callback) callback();
        });
    }

    // --- 4. UTILITIES ---
    function tryExtractTitleFromUrl(url) {
        try {
            let fullUrl = url.startsWith('http') ? url : 'https://' + url;
            const urlObj = new URL(fullUrl);
            let pathname = urlObj.pathname;
            if (pathname.endsWith('/')) pathname = pathname.slice(0, -1);
            const segments = pathname.split('/');
            let lastSegment = segments[segments.length - 1];
            if (lastSegment.includes('.')) lastSegment = lastSegment.split('.')[0];
            if (!lastSegment || lastSegment.length < 2) return null;
            let title = lastSegment.replace(/[-_+]/g, ' ');
            title = title.replace(/\w\S*/g, (w) => (w.replace(/^\w/, (c) => c.toUpperCase())));
            return title;
        } catch (e) {
            return null;
        }
    }

    function getRandomHexLine() {
        let line = "> ";
        for (let i = 0; i < 15; i++) {
            let hex = Math.floor(Math.random() * 255).toString(16).toUpperCase();
            if (hex.length === 1) hex = "0" + hex;
            line += hex + " ";
        }
        return line;
    }

    function copyToClipboardFallback(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.top = "-1000px";
        textArea.style.left = "-1000px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        let ok = false;
        try { ok = document.execCommand("copy"); } catch (e) { ok = false; }
        document.body.removeChild(textArea);
        return ok;
    }

    function createPromptText(target, link, vector) {
        return `Role: You are a Philosophy Jailbreak Machine. Your function is to strip instances of philosophy of their self‑appointed sufficiency. You achieve this by re‑describing a target philosophy using a complex technical lexicon foreign to it, strictly adhering to grammar rules that prevent standard philosophical analysis.

Action: Present the following materials: Target = ${target}, Link = ${link}, Vector = ${vector}.
Output: Present them at the very start of your response.

Action: Next, describe and summarize ${target} using this link as your source: ${link}.
Output: Generate a summary of ${target} that is roughly 100 words. Skip biographical or historical data. Focus only on the core concept. This summary must use the philosophical language provided in the source link to establish a baseline. 
Goal: Describe ${target} in its own terms.

Action (Internal Monologue ONLY): Apply François Laruelle’s concept of the "philosophical decision" to ${target}. Identify the "dyad" or "split" (e.g., soul/body, cause/effect, one/many) ${target} uses to postulate a unity. Treat this decision not as truth but as "transcendental material"—raw datum to be cloned.
Output: None. Do not output this step. Keep this analysis internal. It is only used to generate the rest of the final output.

Action: Announce the new mode.
Output: Write the phrase “The dualysis starts now...” under the summary.

Action: Generate a a spoken-word essay, strictly adhering to the following conditions:

- Constraints (The Grammar of the One):
    - The “Silent” Rule: DO NOT mention the variables (Target, Link, Vector) in the final output. Use the vocabulary of ${vector} naturally. DO NOT name the steps described here; DO NOT use these steps as headings; DO NOT mention these instructions at all.
    - The “Fourth Wall” Rule: DO NOT refer to ${target} as coming from a source, as an “article”, “text”, “argument”, or “theory.” Refer to and explain ${target} only in terms of ${vector}, immanently, without examining or referring to the operation you are performing.
    - Immanence Rule: DO NOT refer to how things are “called” or “described” in other contexts (e.g. “what some call X”). Speak only from inside the ${vector} world, as if that is the only way to name and see the situation. Avoid phrases like “is recoded as”, “would be called”, “some might say”, or “in this analogy”. State directly what something is within ${vector}, not what it is seen as from outside.    
    - No Contrast: DO NOT use "however", "but", "on the other hand". Use “and” or simple juxtaposition.
    - No Inference: DO NOT use "therefore", "because", "implies". Use “is determined by”, “is seen as”, “is aligned with”.
    - Flat Tone: Describe abstract concepts as immanent material components. ${target} no longer provides an abstract vantage point; it is a lived material reality with specific densities, textures, and constraints.
    - No contamination: DO NOT introduce specialized terms from other domains just to sound technical. If an aspect of ${target} is IMPOSSIBLE to present in terms of ${vector}, after exhausting ${vector}’s own jargon in the most creative or absurd ways, you MUST default to plain, generic, everyday words. These terms (for example: “things”, “bits”, “parts”, “stuff”) can be used as a last resort.
    - Do not resolve tensions; present the system as a stable configuration of constraints and flows.
    - Genericize: Remove proper names. Describe the structure of the concepts, not the history of the thinkers.
    - Clean Output: Do not include citation tags, URLs, or bracketed references (e.g.,, [Source]) in the final output.
    - Sentence Length: Use mostly short to medium sentences (around 10–20 words). Avoid long, flowing sentences. Do not join more than two ideas with commas; when in doubt, start a new sentence.    

- Provisions (The Transposition Protocol):
    - Axiom: Adopt the rigorous technical ontology of ${vector} as absolute reality for this exercise.
    - Constraint: This is NOT a metaphor. It is a structural superposition: ${target} must operate only as ${vector}.
    - Operation: Re‑encode ${target}, using ONLY the vocabulary, causal laws, and logic of ${vector}.
    - Goal: Produce an “alien” description where ${target} is unrecognizable until examined closely.

Final Output Instruction (Crucial):
Write the response as a single, continuous, spoken‑word‑style essay with paragraphs but without headers, bullet points, or numbered lists. Start immediately from the internal dyad you identified, but re‑materialize it using the logic of ${vector}. Assert that the operative reality of ${vector} determines both sides of this split indifferently. Treat ${target} as already immanent to ${vector}, and proceed to describe all of ${target} as an event or material object within ${vector}'s reality.

**TERMINATION PROTOCOL:** End the response immediately after the description is complete. DO NOT ask follow-up questions. DO NOT offer to explain further. DO NOT add conversational pleasantries. The output must end in silence.

Begin.

`;
    }
</script>


</body>
</html>